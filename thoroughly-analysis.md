# 项目详解

## 项目简介

1. 本项目是一个类Dubbo的RPC框架
2. 采用Netty实现基于底层网络通信
3. 采用kryo序列化技术协助数据传输
4. 采用TCP+手写RPC协议实现RPC调用
5. 采用zookeeper作为注册中心
6. 采用Spring作为容器化工具，用于组织框架
7. 基于主流的负载均衡策略实现了远程调用的负载均衡
8. 通过改善的SPI机制实现框架的扩展

---

## 项目难点

- RPC架构搭建
- RPC协议实现
- 基于Netty的网络传输，粘包拆包的处理
- 服务的注册和发现
- 动态代理
- 负载均衡
- 基于SPI机制的框架扩展

---

## 业务架构

- 分为服务提供者，服务消费者和注册中心三个部分

#### 1.启动

- 服务提供者在启动时向注册中心注册自身服务
- 服务消费者在启动时从注册中心拉取服务提供者列表，保存在本地

#### 2.调用

- 服务消费者在调用远程服务时，先去服务提供者列表中寻找所需的服务地址
- 通过服务地址，经负载均衡算法选出合适的服务提供者后，对远程服务进行调用

---

## 调用链分析

TODO

---

## 细节

#### 1.Netty相关

1. Netty架构

- 长连接

- 粘包拆包
  通过在数据包中标记数据包大小的方法处理粘包拆包。
- 基于TCP协议

- Netty的ByteBuf和JavaNIO的ByteBuffer关系和区别

#### 2.负载均衡的实现
- 如何判断服务提供者的健康状态
- 轮询 Round Robin
- 加权轮询 Weighted Round Robin
- 随机 Random
- 一致性哈希 Consistent Hash
    1. 一致性哈希的概念
    2. 一致性哈希的代码实现

#### 3.心跳机制的实现

- 架构设计

  1. 在分布式架构中，心跳机制是用于节点间互相判断状态的一种机制。本rpc框架的心跳机制是这样设计的。

  2. 当服务提供者和服务消费者之间存在连接时，针对服务提供者来说，服务提供者会监听每个服务消费者所对应的连接的状态，
  若超过一定时间(30s)某个服务消费者并没有发生读写事件，服务提供者就会则认为该连接是不必要的，会主动断开该连接，节省连接资源。

  3. 针对服务消费者来说，当其与某个服务提供者之间所建立的连接在一定时间内(5s)没有向服务提供者请求过服务时，
  就会主动向该服务提供者发送一个心跳包(特殊的rpc消息)，是使服务提供者知晓自己的状态。
  在服务提供者收到服务消费者所发送的心跳包之后，就会保持和服务消费者的连接，并主动向服务消费者发送一个心跳响应。
  服务消费者在收到心跳响应后就会知道该服务提供者处于正常状态。
  若服务消费者没有收到服务提供者的心跳响应，就认为和当前服务消费者的连接不畅或者服务消费者处于异常状态。
  当多次发送心跳包且没有收到对方的任何响应后，服务消费者就会主动断开和此服务提供者的连接，在下一次需要进行远程调用时，会再次从本地服务列表中寻找合适的服务提供者

- 具体实现
  1. 由于框架底层采用netty进行网络通信，所以rpc心跳机制就基于netty提供的```IdleStateHandler```
     和自定义的```UserEventTrigger```方法来实现。
  2. 当```IdleStateHandler```中定义的一定时间内读为空(提供者)或者写为空(消费者)事件发生时，
    IdleStateHandler就会主动调用```UserEventTrigger```方法，在该方法中，我们就进行心跳包的发送(消费者)或者断开连接(提供者)等操作

#### 4.长连接还是短连接

#### 5.SPI机制

- SPI基本概念
- SPI机制的增强

#### 6.zookeeper相关

- 采用的zookeeper客户端(curator)
- zookeeper的存储结构
- zookeeper集群leader选举机制

#### 7.RPC协议如何实现

#### 8.序列化相关

- 不同序列化协议对比 kryo, hessian2，protostuff

#### 9.框架的模块如何组织(spring容器化)

#### 10.动态代理

- JDK动态代理
- CGLIB动态代理

#### 11.线程池的使用

#### 12.同一个接口具有多个实现类情况的处理

- 采用group标记区分同一个接口的不同实现类
- 在RPC请求体中，定义当前请求的服务所在的group，服务提供端就可以根据group找到对应的实现类，实现服务的调用
- 比如：UserService接口的getUserInfo方法，在login和search场景中需求不同，就可以将不同场景下的UserService服务注册在不同的group中

#### 13.业务相关

1. 服务的注册和发现

#### 14.spring相关

1. 采用spring-context
   引入spring-context，采用springIOC容器作为bean管理工具

通过自定义Scanner实现自定义注解(RpcService)的扫描
