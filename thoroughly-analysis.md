# 项目详解

## 项目简介
1. 本项目是一个类Dubbo的RPC框架 
2. 采用Netty实现基于底层网络通信 
3. 采用kryo序列化技术协助数据传输 
4. 采用TCP+手写RPC协议实现RPC调用 
5. 采用zookeeper作为注册中心 
6. 采用Spring作为容器化工具，用于组织框架 
7. 基于主流的负载均衡策略实现了远程调用的负载均衡 
8. 通过改善的SPI机制实现框架的扩展

---
## 项目难点
- RPC架构搭建
- RPC协议实现
- 基于Netty的网络传输，粘包拆包的处理
- 服务的注册和发现
- 动态代理
- 负载均衡
- 基于SPI机制的框架扩展

---

## 业务架构
- 分为服务提供者，服务消费者和注册中心三个部分

#### 1.启动
- 服务提供者在启动时向注册中心注册自身服务
- 服务消费者在启动时从注册中心拉取服务提供者列表，保存在本地

#### 2.调用
- 服务消费者在调用远程服务时，先去服务提供者列表中寻找所需的服务地址
- 通过服务地址，经负载均衡算法选出合适的服务提供者后，对远程服务进行调用

---
## 调用链分析
TODO

---

## 细节
#### 1.Netty相关
1. Netty架构
- 长连接
- 心跳机制
  1. 在rpc框架中，心跳机制是用于服务消费者和服务提供者判断对方状态的一种机制，本rpc框架的心跳机制是这样实现的
  2. 首先，由于框架底层采用了netty作为网络通信工具，因此
  3. 
- 粘包拆包
  通过在数据包中标记数据包大小的方法处理粘包拆包。
- 基于TCP协议

- Netty的ByteBuf和JavaNIO的ByteBuffer关系和区别

#### 2.负载均衡的实现
- 轮询 Round Robin
- 加权轮询 Weighted Round Robin
- 随机 Random
- 一致性哈希 Consistent Hash 
  1. 一致性哈希的概念
  2. 一致性哈希的代码实现

#### 3.心跳机制的实现

#### 4.长连接还是短连接

#### 5.SPI机制
- SPI基本概念
- SPI机制的增强

#### 6.zookeeper相关
- 采用的zookeeper客户端(curator)
- zookeeper的存储结构
- zookeeper集群leader选举机制

#### 7.RPC协议如何实现

#### 8.序列化相关
- 不同序列化协议对比 kryo, hessian2，protostuff

#### 9.框架的模块如何组织(spring容器化)

#### 10.动态代理
- JDK动态代理
- CGLIB动态代理

#### 11.线程池的使用

#### 12.同一个接口具有多个实现类情况的处理
- 采用group标记区分同一个接口的不同实现类
- 在RPC请求体中，定义当前请求的服务所在的group，服务提供端就可以根据group找到对应的实现类，实现服务的调用
- 比如：UserService接口的getUserInfo方法，在login和search场景中需求不同，就可以将不同场景下的UserService服务注册在不同的group中

#### 13.业务相关
1. 服务的注册和发现

#### 14.spring相关
1. 采用spring-context
引入spring-context，采用springIOC容器作为bean管理工具

通过自定义Scanner实现自定义注解(RpcService)的扫描
