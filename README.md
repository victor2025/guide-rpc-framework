# 基于Netty的RPC框架 项目详解

## 项目简介

1. 本项目是一个类Dubbo的RPC框架
2. 采用Netty实现基于底层网络通信
3. 采用kryo序列化技术协助数据传输
4. 采用TCP+手写RPC协议实现RPC调用
5. 采用zookeeper作为注册中心
6. 采用Spring作为容器化工具，用于组织框架
7. 基于主流的负载均衡策略实现了远程调用的负载均衡
8. 通过改善的SPI机制实现框架的扩展

---

## 项目难点

- RPC架构搭建
- RPC协议实现，粘包拆包的处理
- 基于Netty的网络传输
- 心跳机制的实现
- 服务的注册和发现
- 动态代理
- 负载均衡
- 基于SPI机制的框架扩展

---

## 业务架构

- 分为服务提供者，服务消费者和注册中心三个部分

#### 1.启动

- 服务提供者在启动时向注册中心注册自身服务
- 服务消费者在启动时从注册中心拉取服务提供者列表，保存在本地

#### 2.调用

- 服务消费者在调用远程服务时，先去服务提供者列表中寻找所需的服务地址
- 通过服务地址，经负载均衡算法选出合适的服务提供者后，对远程服务进行调用

#### 3.流程分析

- 服务提供者启动时，将远程服务通过**注册器**注册在注册中心(zookeeper)中， 包括服务名称，服务地址等信息。在zookeeper中以持久节点的形式保存。

- 服务消费者启动时，在第一次和对某个服务发起远程调用时，会主动从注册中心拉取服务列表，保存在本地。
  (并在对应的服务节点上添加watcher，之后当对应服务列表出现变化时，会收到通知，以及时更新服务列表)

- 服务消费者在对某个远程服务发起调用时，首先会从本地服务列表中查找对应的服务，若找到可以对应的服务， 就首先尝试调用本地服务列表中的服务。若无法找到对应的服务，则会从注册中心中拉取对应服务列表。 若拉取后仍无法找到对应服务，则抛出异常。

---

## 架构相关细节

#### 1.心跳机制的实现

- 架构设计

    1. 在分布式架构中，心跳机制是用于节点间互相判断状态的一种机制。本rpc框架的心跳机制是这样设计的。

    2. 当服务提供者和服务消费者之间存在连接时，针对服务提供者来说，服务提供者会监听每个服务消费者所对应的连接的状态， 若超过一定时间(30s)
       某个服务消费者并没有发生读写事件，服务提供者就会则认为该连接是不必要的，会主动断开该连接，节省连接资源。

    3. 针对服务消费者来说，当其与某个服务提供者之间所建立的连接在一定时间内(5s)没有向服务提供者请求过服务时， 就会主动向该服务提供者发送一个心跳包(特殊的rpc消息)，是使服务提供者知晓自己的状态。
       在服务提供者收到服务消费者所发送的心跳包之后，就会保持和服务消费者的连接，并主动向服务消费者发送一个心跳响应。 服务消费者在收到心跳响应后就会知道该服务提供者处于正常状态。
       若服务消费者没有收到服务提供者的心跳响应，就认为和当前服务消费者的连接不畅或者服务消费者处于异常状态。
       当多次发送心跳包且没有收到对方的任何响应后，服务消费者就会主动断开和此服务提供者的连接，在下一次需要进行远程调用时，会再次从本地服务列表中寻找合适的服务提供者

- 具体实现
    1. 由于框架底层采用netty进行网络通信，所以rpc心跳机制就基于netty提供的**IdleStateHandler(空闲状态处理器)**
       和自定义的**UserEventTrigger(用户事件触发器)**方法来实现。
    2. 当**IdleStateHandler**中定义的一定时间内读为空(提供者)或者写为空(消费者)事件发生时， IdleStateHandler就会主动调用**UserEventTrigger**
       方法，在该方法中，我们就进行心跳包的发送(消费者)或者断开连接(提供者)等操作

#### 2.长连接还是短连接

rpc通信中采用长连接，在服务消费者和服务生产者之间建立连接之后， 服务消费者采用心跳机制**通知服务提供者保持连接**。 服务提供者在一定时间内没有接收到服务消费者的任何请求(包括rpc调用和心跳包)时，会**主动断开连接**。

服务消费者在和某个服务提供者建立连接后，会将对应的channel存储在本地缓存中(Map结构)， 在下一次调用该服务提供者提供的某个服务时，首先就会从缓存中获取对应的channel，实现连接的复用，节省连接资源。

#### 3.负载均衡的实现

- 如何判断服务提供者的健康状态
- 轮询 Round Robin
- 加权轮询 Weighted Round Robin
- 随机 Random
- 一致性哈希 Consistent Hash
    1. 一致性哈希的概念
    2. 一致性哈希的代码实现

#### 4.非阻塞式调用

completableFuture的运用

#### 4.SPI机制

- SPI基本概念
- SPI机制的增强

#### 5.服务如何注册和发现

#### 7.RPC协议如何实现

- 在rpc调用中，服务消费者需要将调用请求发送给服务提供者，服务提供者需要向服务消费者返回调用结果， 除此之外，服务消费者和服务提供者之间也需要通过基于心跳包的心跳机制来检测对方的状态。 这些信息的传输都需要rpc协议来实现。
- 消息发送者首先需要编码**消息长度，消息类型(rpc请求/心跳包)，序列化类型，请求Id等信息**，作为请求头 之后通过序列化和压缩**请求信息对象(包含目标方法名和参数等信息)**，形成请求体，
  请求头和请求体组成完整的请求报文，发送给服务提供者
- 消息接收者在接收到消息后，按照同样的规则解析数据，获取请求包中的相关信息，根据信息进行相应的处理。

#### 9.框架的模块如何组织(spring容器化)

#### 10.动态代理

- JDK动态代理
- CGLIB动态代理

#### 11.线程池的使用

#### 12.同一个接口具有多个实现类情况的处理

- 采用group标记区分同一个接口的不同实现类
- 在RPC请求体中，定义当前请求的服务所在的group，服务提供端就可以根据group找到对应的实现类，实现服务的调用
- 比如：UserService接口的getUserInfo方法，在login和search场景中需求不同，就可以将不同场景下的UserService服务注册在不同的group中

---

## 组件相关细节

#### 1.Netty相关

1. Netty架构

- 多reactor多线程

- 粘包拆包 通过在数据包中标记数据包大小的方法处理粘包拆包。
- 基于TCP协议

- Netty的ByteBuf和JavaNIO的ByteBuffer关系和区别

#### 2.zookeeper相关

- 采用的zookeeper客户端(curator)
- zookeeper的存储结构
- zookeeper集群leader选举机制
- ZAB协议
- zookeeper的CP策略

#### 3.序列化相关

- 不同序列化协议对比 kryo, hessian2，protostuff

#### 4.spring相关

配置文件读取，包扫描，对象管理

1. 采用spring-context 引入spring-context，采用springIOC容器作为bean管理工具

通过自定义Scanner实现自定义注解(RpcService)的扫描

--- 

## 常见问题

#### 1.为什么要用TCP协议，不用HTTP协议

- 首先，使用TCP协议而不用HTTP协议不是因为HTTP协议不能用来做rpc调用。 因为有其他的**rpc框架，比如gRPC**或者**rpc组件，比如Feign**， 底层都是基于HTTP协议实现的RPC调用的。
- 本框架没有采用HTTP协议而是采用TCP协议进行传输主要是考虑到性能原因。
- 在HTTP协议中，一个请求报文由请求行、请求头、空行和请求数据四个部分组成， 其中，请求头中存在众多冗余字段的存在(比如：**连接类型、user-agent等等**)， 效率较低的编码方式等原因，占用了额外的资源，导致性能下降。
    1. 在HTTP1.1中，**请求行和请求头规定使用ASCII编码**，属于字符编码方式， 因此，就算将HTTP请求头中所有冗余字段均去除，采用http协议进行rpc调用时，除了请求体之外，
       请求行和请求头仍然会占用几十个字节(主要在请求行中，ipv4占30个字节左右，ipv6更长)的空间。
    2. HTTP2.0中，通过数据帧+二进制编码的方式发送数据，并采用了连接多路复用技术，相对于HTTP1.1来说提升了传输效率，
       (这也是gRPC采用HTTP2.0作为底层传输协议的原因之一)
       但是它的每个帧的头部就占了10字节左右的空间，就算不算上请求体，每个帧也都达到了几十字节的大小。
    3. 而基于TCP协议实现的**自定义rpc协议**，请求头只有**16字节**的大小，并且可以包含消息类型，序列化类型等信息， 相对于直接采用http协议来说，**虽然在编码方面增加了复杂性，但是可以实现更加高效的数据传输和编解码**。
    
- 我认为，http协议为了实现自己的通用性(超文本传输、文件传输、不同类型响应的解析)，在效率上进行了妥协，
而rpc协议可以面向服务进行制定，可以有效精简报文，并提升传输和编解码的效率。

#### 2.HTTP请求头存在哪些字段

````http request
GET /home.html HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/testpage.html
Connection: keep-alive
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"
Cache-Control: max-age=0 
````

#### 3.TCP粘包和拆包产生的原因
- 粘包拆包是在TCP通信中可能发生的情况，由于TCP属于**面向流的传输层协议**，并不了解应用层对于数据包的定义，
所以TCP报文在进行数据传输时，不会根据应用层数据包的情况进行划分，而会根据缓冲区情况或者最大报文长度(MSS)进行划分。
- 粘包拆包发生的情况：
  1. 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
  2. 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
  3. 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
  4. 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
- 若是基于HTTP协议实现的rpc协议，则不需要考虑该问题，因为http属于应用层协议，已经解决了粘包拆包问题。
- 若是基于TCP协议实现的rpc协议，就必需解决粘包拆包问题，否则就会出现错误。


  

